use asp_library::copland::*;
use data_encoding::BASE64;
use anyhow::{Context, Result};
use std::env;

// Include crates used to perform measurement
use sha2::{Sha256, Digest};

// Define functions used to perform measurement (optional)


fn body() -> Result<String> {

// Step 1. Parse the single command line argument,
//         which must be a string containing a JSON encoded ASPRunRequest
//         No specidialization required.

    let args: Vec <String> = env::args().collect();

    if args.len() < 2 {
        Err(anyhow::anyhow!("ASPRunRequest not supplied as command line argument"))
    } else {

        let json_request = &args[1];
        let req: ASPRunRequest = serde_json::from_str(json_request)?;

// Step 2. Extract the argument(s) required by this ASP,
//         from the ASPRunRequest.ASP_ARGS field

        let args_map = req.ASP_ARGS;
        let filename = &args_map.get("filepath").context("filename argument not provided to ASP, hashfile_id")?;
// Step 3. Do the measurement for this ASP

        let bytes = std::fs::read(filename)?; // Vec<u8>

        let hash = Sha256::digest(&bytes);

// Step 4. Place the measured value into an Evidence structure
//         which is a Vector<String>.
//         The string must be BASE64 encoded

        let hash_string = format!("{:?}", hash);
        let hash_b64: String = BASE64.encode(&hash_string.into_bytes());

        let evidence = RawEv::RawEv(vec![hash_b64]);

// Step 5. Construct the ASPRunResponse with this evidence, and
//         generate a JSON encoding of this structure.
//         No specidialization required.

        let  response = ASPRunResponse { TYPE: "RESPONSE".to_string(),
                                         ACTION: "ASP_RUN".to_string(),
                                         SUCCESS: true,
                                         PAYLOAD:  evidence};
        let response_json = serde_json::to_string(&response)?;
        Ok (response_json)
    }
}

fn main() -> () {

// Step 6. Determine any error was generated performing the measurement.
//         If an error occurred, create an ASPRunResponse with "SUCCESS: false"
//         No specidialization required.
    let response_json = match body() {
        Ok(resp) => resp,
        Err(_error) => {
            let  response = ASPRunResponse { TYPE: "RESPONSE".to_string(),
                                             ACTION: "ASP_RUN".to_string(),
                                             SUCCESS: false,
                                             PAYLOAD:  RawEv::RawEv(Vec::new())};
            serde_json::to_string(&response).unwrap_or_else(|error| {panic!("Failed to json.encode failure response: {error:?}");})
        }
    };

// Step 7. Print the JSON encoded ASPRunResponse to stdout.
//         The caller will capture stdout to receive the response from this ASP.
//         No specidialization required.

    println!("{response_json}");
    ()
}
